import UIKit
/*:
 # Lista 4: Loops (laÃ§os de repetiÃ§Ã£o)
 ### 1. SequÃªncia 1, 2, 3, PIM [ğŸ]
 FaÃ§a uma funÃ§Ã£o que imprima os nÃºmeros entre 1 e 40, porÃ©m no lugar dos nÃºmeros mÃºltiplos de 4 apareÃ§a a palavra PIM. Por exemplo: 1, 2, 3, PIM, 5, 6, 7, PIM e assim por diante. Resolva usando ```for```.
 */
// cÃ³digo aqui

/*:
 ### 2. Imprimir 100 nÃºmeros [ğŸ]
 Imprima todos os nÃºmeros de 0 atÃ© 100 (nÃ£o incluso).
 */
 // cÃ³digo aqui

/*:
 ### 3. Imprimir 101 nÃºmeros [ğŸ]
 Imprima todos os nÃºmeros de 0 a 100, inclusive.
 */
 // cÃ³digo aqui

/*:
 ### 4. Intervalo entre dois nÃºmeros [ğŸ]
 FaÃ§a uma funÃ§Ã£o que receba dois nÃºmeros inteiros e print todos os nÃºmeros inteiros que estÃ£o no intervalo compreendido por eles.
 */
 // cÃ³digo aqui

/*:
 ### 5. Pares entre 1 e 50 [ğŸ]
 Imprima todos os nÃºmeros pares entre 1 e 50 (inclusive).
 */
 // cÃ³digo aqui

/*:
 ### 6. ProgressÃ£o AritmÃ©tica [ğŸ]
 Escreva uma funÃ§Ã£o que receba um valor inicial A e uma razÃ£o R e imprima uma seqÃ¼Ãªncia em P.A. contendo 10 valores.
 *Por exemplo: ```A = 100, R = 7```*
 *Imprime: ```100, 107, 114, 121, 128, 135, 142, 149, 156, 163```*
 */
 // cÃ³digo aqui

/*:
 ### 7. Soma dos nÃºmeros menores que N [ğŸ]
 Escreva um programa que encontre o somatÃ³rio de todos os nÃºmeros de 1 atÃ© N. O nÃºmero N vai ser sempre um inteiro maior que zero.
 */
 // cÃ³digo aqui

/*:
 ### 8. Tabuada [ğŸ]
 FaÃ§a uma funÃ§Ã£o que receba um nÃºmero e imprima no console a tabuada de 1 a 10 no nÃºmero recebido.
 */
 // cÃ³digo aqui

/*:
 ### 9. While menor que 50 [ğŸ]
 Imprima os nÃºmeros de 1 a 50 usando a estrutura "while"
 */
 // cÃ³digo aqui

/*:
 ### 10. Caculadora de investimento [ğŸğŸ]
 Escreva uma funÃ§Ã£o para calcular o rendimento de um investimento com base nos seguintes dados de entrada. Valor inicial, valor a ser depositado todos os meses, quantidade de meses e taxa de rendimento mensal.
 */
 // cÃ³digo aqui

/*:
 ### 11. Crescimento populacional [ğŸğŸ]
 Supondo que a populaÃ§Ã£o de um paÃ­s A seja da ordem de 80000 habitantes com uma taxa anual de crescimento de 3% e que a populaÃ§Ã£o de B seja 200000 habitantes com uma taxa de crescimento de 1.5%. FaÃ§a um programa que calcule e escreva o nÃºmero de anos necessÃ¡rios para que a populaÃ§Ã£o do paÃ­s A ultrapasse ou iguale a populaÃ§Ã£o do paÃ­s B, mantidas as taxas de crescimento.
 */
 // cÃ³digo aqui

/*:
 ### 12. Escada de # [ğŸğŸ]
 Escreva uma funÃ§Ã£o para desenhar no console uma escada de # dada a quantidade de degraus
 * Callout(Exemplo: cinco degraus):
 
    \#
 
    \##
 
    \###
 
    \####
 
    \#####
 */
 // cÃ³digo aqui

/*:
 ### 13. MÃ©dia (com while) [ğŸğŸ]
 Escreva, usando while, um programa para calcular a mÃ©dia de N nÃºmeros. O valor de N Ã© dado pelo usuÃ¡rio.
 Para simular os nÃºmeros digitados pelo usuÃ¡rio, use o retorno da funÃ§Ã£o:

```func getNumberFromUser() -> Int {```

   ```return Int.random(in: 1...10)```
 
```}```
 */
 // cÃ³digo aqui

/*:
 ### 14. PirÃ¢mide de Sinuca [ğŸğŸ]
 Lembra da pirÃ¢mide ou triÃ¢ngulo feito com as bolas de bilhar que preparamos ao comeÃ§ar uma partida de sinuca? Para construir um triÃ¢ngulo clÃ¡ssico (de 5 nÃ­veis) vocÃª precisa de 15 bolas. Com 3 bolas, vocÃª pode construir um triangulo de 2 nÃ­veis, etc.

 Por exemplo,
 - ```pyramid(1) == 1```

 - ```pyramid(3) == 2```

 - ```pyramid(6) == 3```

 - ```pyramid(10) == 4```

 - ```pyramid(15) == 5```

 Escreva uma funÃ§Ã£o que pega o numero de bolas (â‰¥1) e calcula o mÃ¡ximo de nÃ­veis que Ã© possÃ­vel construir a pirÃ¢mide, como no exemplo acima.
 */
 // cÃ³digo aqui

/*:
 ### 15. Soma Ã­mpares mÃºltiplos de 3 [ğŸğŸ]
 FaÃ§a uma funÃ§Ã£o que retorne a soma de todos os nÃºmeros Ã­mpares que sÃ£o mÃºltiplos de trÃªs e que se encontram no conjunto dos nÃºmeros entre 1 e 500.
 */
 // cÃ³digo aqui

/*:
 ### 16. Alerte as ovelhas [ğŸğŸğŸ]
 Lobos foram reintroduzidos na GrÃ£-Bretanha. VocÃª pastoreia ovelhas e agora estÃ¡ sofrendo com lobos tentando se disfarÃ§ar de ovelha. Por sorte, vocÃª Ã© excelente em perceber os lobos disfarÃ§ados.

 Avise a ovelha imediatamente na frente do lobo que ela estÃ¡ a beira de ser devorada pelo lobo. Lembre que vocÃª estÃ¡ na frente da fila, que fica no final do array / lista. Abaixo um esquema da fila, com um exemplo numerado e visual das posiÃ§Ãµes das ovelhas.
 
 ![Tabela 1](L4_E16.png)

 
 Se o lobo for o animal mais prÃ³ximo de vocÃª, retorne ```"Por favor, vÃ¡ embora e pare de comer minhas ovelhas"```. Caso contrÃ¡rio, retorne ```"Hey! Ovelha nÃºmero N! VocÃª vai ser devorada pelo lobo!"``` onde N Ã© a posiÃ§Ã£o da ovelha exatamente na frente do lobo.

 **Nota:** sempre terÃ¡ apenas um lobo na fila.

 ### **Exemplos**

 *Input:Â ```["sheep", "sheep", "sheep", "wolf", "sheep", "sheep"]```*
 *Output:Â ```"Hey! Ovelha nÃºmero 2! VocÃª vai ser devorada pelo lobo!"```*

 *Input:```["sheep", "sheep", "wolf"]```*
 *Output:```"Por favor, vÃ¡ embora e pare de comer minhas ovelhas"```*
 */
 // cÃ³digo aqui

/*:
 ### 17. NÃºmero Perfeito [ğŸğŸğŸ]
 Um nÃºmero se diz perfeito se Ã© igual Ã  soma de seus divisores prÃ³prios. Divisores prÃ³prios de um nÃºmero positivo N sÃ£o todos os divisores inteiros positivos de N exceto o prÃ³prio N. Por exemplo, o nÃºmero 6, seus divisores prÃ³prios sÃ£o 1, 2 e 3, cuja soma Ã© igual Ã  6.

 FaÃ§a uma funÃ§Ã£o que receba um nÃºmero e retorne true caso o nÃºmero seja perfeito e false caso nÃ£o seja.
 */
 // cÃ³digo aqui

/*:
 ### 18. NÃºmero Perfeito 2 [ğŸğŸğŸ]
 Agora que vocÃª jÃ¡ tem uma funÃ§Ã£o que verifica se um nÃºmero Ã© perfeito (ver exercÃ­cios anterior), faÃ§a uma funÃ§Ã£o que exibe todos os nÃºmeros perfeitos existentes entre 1 e 500.
 */
 // cÃ³digo aqui

/*:
 ### 19. Ã‰ primo? [ğŸğŸğŸ]
 Implemente uma funÃ§Ã£o que receba um nÃºmero e retorne se Ã© primo ou nÃ£o.

*Nota: 0, 1 e nÃºmeros negativos nÃ£o sÃ£o primos.*
 */
 // cÃ³digo aqui

/*:
 ### 20. O PrÃ³ximo Doubleton [ğŸğŸğŸğŸ¤¯]
 NÃ³s vamos chamar um nÃºmero natural de "nÃºmero doubleton" se ele contÃ©m exatamente 2 digitos distintos. Por exemplo, 23, 35, 100, 12121 sÃ£o nÃºmeros doubleton, e 123 e 9980 nÃ£o sÃ£o.

 Para qualquer nÃºmero natural n (entre 1 a 1.000.000), vocÃª precisa encontrar o prÃ³ximo nÃºmero doubleton. Se n Ã© um doubleton, retorne o prÃ³ximo nÃºmero doubleton maior que n.
 */
 // cÃ³digo aqui
